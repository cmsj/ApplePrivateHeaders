/*
* This header is generated by classdump-dyld 1.0
* on Wednesday, April 28, 2021 at 2:51:02 PM British Summer Time
* Operating System: Version 11.3 (Build 20E232)
* Image Source: /System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork
* classdump-dyld is licensed under GPLv3, Copyright Â© 2013-2016 by Elias Limneos.
*/

#import <CFNetwork/CFNetwork-Structs.h>
#import <CFNetwork/NSURLSessionTask.h>
#import <libobjc.A.dylib/NSURLSessionTaskSubclass.h>
#import <libobjc.A.dylib/NSURLSessionDataTaskSubclass.h>
#import <libobjc.A.dylib/NSURLSessionUploadTaskSubclass.h>
#import <libobjc.A.dylib/__NSCFURLSessionConnectionDelegate.h>

@protocol OS_dispatch_data, OS_dispatch_source;
@class __NSCFURLSessionConnection, NSURL, NSObject, NSInputStream, NSOutputStream, NSOperationQueue, NSString;

@interface __NSCFLocalSessionTask : NSURLSessionTask <NSURLSessionTaskSubclass, NSURLSessionDataTaskSubclass, NSURLSessionUploadTaskSubclass, __NSCFURLSessionConnectionDelegate> {

	__NSCFURLSessionConnection* _cfConn;
	NSURL* _uploadFile;
	NSObject*<OS_dispatch_data> _dataTaskData;
	/*^block*/id _dataTaskCompletion;
	NSObject*<OS_dispatch_data> _pendingResponseBytes;
	unsigned long long _suspendCount;
	/*^block*/id _async_initialization;
	NSObject*<OS_dispatch_source> _resourceTimeout;
	os_unfair_lock_s _connKeyLock;
	HTTPConnectionCacheKey* _connKey;
	double _startTimeoutTime;
	NSObject*<OS_dispatch_source> _startTimeoutTimer;
	NSObject*<OS_dispatch_source> _payloadTransmissionTimer;
	NSObject*<OS_dispatch_source> _willSendRequestTimer;
	NSInputStream* _socketReadStreamForUpgrade;
	NSOutputStream* _socketWriteStreamForUpgrade;
	shared_ptr<TransportConnection>* _connectionForUpgrade;
	NSObject*<OS_dispatch_data> _extraBytes;
	NSOperationQueue* _connectionWorkQueue;
	int _connectionWorkQueueSuspensionCount;
	char _pendingResponseDisposition;
	char _pendingResponseDisposition_didFinish;
	char _didIssueWaitingForConnectivity;
	char _didIssueDidFinish;
	char _suspendedForDisposition;
	char _didCheckMixedReplace;
	char _isMixedReplace;
	char _sentDidFinishCollectingMetrics;

}

@property (retain) __NSCFURLSessionConnection * cfConn;              //@synthesize cfConn=_cfConn - In the implementation block
@property (readonly) unsigned long long hash; 
@property (readonly) Class superclass; 
@property (copy,readonly) NSString * description; 
@property (copy,readonly) NSString * debugDescription; 
-(void)_onqueue_completeInitialization;
-(void)_onqueue_cancel;
-(void)_onqueue_setupNextEffectiveConfigurationWithCompletionHandler:(/*^block*/id)arg1 ;
-(void)_onSessionQueue_disavow;
-(id)_onqueue_strippedMutableRequest;
-(id)initWithOriginalRequest:(id)arg1 ident:(unsigned long long)arg2 taskGroup:(id)arg3 ;
-(__NSCFURLSessionConnection *)cfConn;
-(void)_onqueue_didReceiveResponse:(id)arg1 completion:(/*^block*/id)arg2 ;
-(void)_private_onqueue_didReceiveResponseDisposition:(long long)arg1 completion:(/*^block*/id)arg2 ;
-(void)_onqueue_suspend;
-(void)connection:(id)arg1 wasRedirected:(id)arg2 newRequest:(id)arg3 responseCallback:(/*^block*/id)arg4 ;
-(void)connection:(id)arg1 request:(id)arg2 needsNewBodyStreamCallback:(/*^block*/id)arg3 ;
-(void)connection:(id)arg1 didReceiveResponse:(id)arg2 completion:(/*^block*/id)arg3 ;
-(void)connection:(id)arg1 willCacheResponse:(id)arg2 responseCallback:(/*^block*/id)arg3 ;
-(void)connection:(id)arg1 didFinishCollectingMetrics:(id)arg2 completion:(/*^block*/id)arg3 ;
-(void)connectionWillFinishLoading:(id)arg1 ;
-(void)connection:(id)arg1 didFinishLoadingWithError:(id)arg2 ;
-(void)connection:(id)arg1 challenged:(id)arg2 authCallback:(/*^block*/id)arg3 ;
-(void)connection:(id)arg1 didReceiveData:(id)arg2 completion:(/*^block*/id)arg3 ;
-(void)connection:(id)arg1 sentBodyBytes:(id)arg2 totalBytes:(id)arg3 expectedBytes:(id)arg4 ;
-(void)connection:(id)arg1 _willSendRequestForEstablishedConnection:(id)arg2 completion:(/*^block*/id)arg3 ;
-(void)connection:(id)arg1 waitingWithReason:(long long)arg2 ;
-(void)connection:(id)arg1 _conditionalRequirementsChanged:(char)arg2 ;
-(void)connection:(id)arg1 didReceiveSocketInputStream:(id)arg2 outputStream:(id)arg3 ;
-(void)connection:(id)arg1 needConnectedSocketToHost:(id)arg2 port:(unsigned long long)arg3 completion:(/*^block*/id)arg4 ;
-(void)connection:(id)arg1 didReceiveTCPConnection:(shared_ptr<TransportConnection>*)arg2 extraBytes:(id)arg3 ;
-(void)_onqueue_resume;
-(void)_onqueue_adjustPoolPriority;
-(void)_onqueue_adjustLoadingPoolPriority;
-(void)_onqueue_didReceiveResponse:(id)arg1 redirectRequest:(id)arg2 withCompletion:(/*^block*/id)arg3 ;
-(void)_onqueue_didReceiveChallenge:(id)arg1 request:(id)arg2 withCompletion:(/*^block*/id)arg3 ;
-(void)_onqueue_willCacheResponse:(id)arg1 withCompletion:(/*^block*/id)arg2 ;
-(void)_onqueue_didFinishCollectingMetrics:(id)arg1 completion:(/*^block*/id)arg2 ;
-(void)_task_onqueue_didFinish;
-(void)_onqueue_didFinishWithError:(id)arg1 ;
-(void)_onqueue_didReceiveDispatchData:(id)arg1 completion:(/*^block*/id)arg2 ;
-(void)_task_onqueue_didReceiveDispatchData:(id)arg1 completionHandler:(/*^block*/id)arg2 ;
-(void)_onqueue_needNewBodyStream:(id)arg1 withCompletion:(/*^block*/id)arg2 ;
-(void)_onqueue_willSendRequestForEstablishedConnection:(id)arg1 withCompletion:(/*^block*/id)arg2 ;
-(void)_onqueue_connectionWaitingWithReason:(long long)arg1 ;
-(void)_onqueue_conditionalRequirementsChanged:(char)arg1 ;
-(void)_onqueue_needConnectedSocketToHost:(id)arg1 port:(unsigned long long)arg2 withCompletion:(/*^block*/id)arg3 ;
-(void)_onqueue_didSendBodyBytes:(long long)arg1 totalBytesSent:(long long)arg2 totalBytesExpectedToSend:(long long)arg3 ;
-(void)_onqueue_cancel_with_error:(id)arg1 ;
-(void)_onqueue_adjustPriorityHint:(float)arg1 incremental:(char)arg2 ;
-(void)_onqueue_adjustBytesPerSecondLimit:(long long)arg1 ;
-(void)_onqueue_expectedProgressTargetChanged;
-(void)_askForConnectedSocketLater;
-(void)_setConnectionCacheKey:(HTTPConnectionCacheKey*)arg1 ;
-(char)_needSendingMetrics;
-(void)_didSendMetrics;
-(void)setCfConn:(__NSCFURLSessionConnection *)arg1 ;
-(void)dealloc;
-(id)error:(id)arg1 code:(long long)arg2 ;
-(void)set_timeoutIntervalForResource:(double)arg1 ;
-(void)cancel_with_error:(id)arg1 ;
-(void)set_TLSMaximumSupportedProtocolVersion:(unsigned short)arg1 ;
-(void)set_TLSMinimumSupportedProtocolVersion:(unsigned short)arg1 ;
-(void)startResourceTimer;
-(id)resourceTimeoutError;
-(id)initWithBackgroundTaskInfo:(id)arg1 taskGroup:(id)arg2 ;
@end

