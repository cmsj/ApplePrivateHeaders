/*
* This header is generated by classdump-dyld 1.0
* on Wednesday, April 28, 2021 at 2:51:54 PM British Summer Time
* Operating System: Version 11.3 (Build 20E232)
* Image Source: /System/Library/Frameworks/PencilKit.framework/Versions/A/PencilKit
* classdump-dyld is licensed under GPLv3, Copyright Â© 2013-2016 by Elias Limneos.
*/

#import <PencilKit/PencilKit-Structs.h>
#import <PencilKit/PKStroke.h>

@interface _PKClippedStroke : PKStroke {

	vector<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>>>* _maskPaths;
	vector<_PKFloatRange, std::__1::allocator<_PKFloatRange>>* _centerlineSlices;

}
+(id)sliceWithEraser:(const vector<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>>>*)arg1 toClip:(id)arg2 clipType:(int)arg3 ;
+(id)sliceWithEraser:(const vector<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>>>*)arg1 toClip:(id)arg2 ;
-(id)mask;
-(CGRect)_calculateBounds;
-(vector<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>>>*)maskPaths;
-(id)initWithArchive:(const Stroke*)arg1 sortedUUIDs:(id)arg2 inks:(id)arg3 parent:(id)arg4 isHidden:(char)arg5 transientArchiveDictionary:(id)arg6 ;
-(unsigned)saveToArchive:(Stroke*)arg1 sortedUUIDs:(id)arg2 inks:(id)arg3 withPathData:(char)arg4 parent:(id)arg5 transient:(char)arg6 ;
-(vector<_PKFloatRange, std::__1::allocator<_PKFloatRange>>*)centerlineSlices;
-(id)initWithStroke:(id)arg1 hidden:(char)arg2 version:(PKStrokeID)arg3 ink:(id)arg4 transform:(CGAffineTransform)arg5 ;
-(id)initWithInk:(id)arg1 strokePath:(id)arg2 transform:(CGAffineTransform)arg3 mask:(id)arg4 ;
-(id)initWithStroke:(id)arg1 ;
-(CGPathRef)newPathRepresentation;
-(void)_appendPointsOfInterestForSelection:(vector<CGPoint, std::__1::allocator<CGPoint>>*)arg1 ;
-(id)maskedPathRanges;
-(char)intersectsPoint:(CGPoint)arg1 boundsOutset:(double)arg2 minimumStrokeThreshold:(double)arg3 ;
-(char)intersectsLineFrom:(CGPoint)arg1 to:(CGPoint)arg2 minThreshold:(double)arg3 ;
-(char)intersectsClosedStroke:(id)arg1 ;
-(id)sliceWithEraser:(const vector<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>>>*)arg1 ;
-(id)sliceWithMask:(const vector<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint>>>>*)arg1 ;
-(void)debugRender:(CGContextRef)arg1 ;
-(CGPathRef)selectionPathRepresentationWithPointsCount:(int*)arg1 ;
-(char)intersectsPoint:(CGPoint)arg1 ;
-(void)generatePolyHull;
-(void)calculateCenterlineSlices;
@end

